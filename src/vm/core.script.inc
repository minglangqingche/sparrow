static const char* core_module_code = 
"class Null {}\n"
"class bool {}\n"
"class i32 {}\n"
"class f64 {}\n"
"class Fn {}\n"
"class Thread {}\n"
"class NativePointer {}\n"
"\n"
"class Sequence {\n"
"    all (func) {\n"
"        for element in self {\n"
"            if !func.call(element) {\n"
"                return true;\n"
"            }\n"
"        }\n"
"        return true;\n"
"    }\n"
"\n"
"    any(func) {\n"
"        for element in self {\n"
"            if func.call(element) {\n"
"                return true;\n"
"            }\n"
"        }\n"
"        return false;\n"
"    }\n"
"\n"
"    contains(element) {\n"
"        for item in self {\n"
"            if element == item {\n"
"                return true;\n"
"            }\n"
"        }\n"
"        return false;\n"
"    }\n"
"\n"
"    len {\n"
"        let res = 0;\n"
"        for element in self {\n"
"            res = res + 1;\n"
"        }\n"
"        return res;\n"
"    }\n"
"\n"
"    count(func) {\n"
"        let res = 0;\n"
"        for element in self {\n"
"            if (func.call(element)) {\n"
"                res = res + 1;\n"
"            }\n"
"        }\n"
"        return res;\n"
"    }\n"
"\n"
"    each(func) {\n"
"        for element in self {\n"
"            func.call(element);\n"
"        }\n"
"    }\n"
"\n"
"    is_empty {\n"
"        return iterate(null) ? false : true;\n"
"    }\n"
"\n"
"    map(transformation) {\n"
"        return MapSequence.new(self, transformation);\n"
"    }\n"
"\n"
"    where(predicate) {\n"
"        return WhereSequence.new(self, predicate);\n"
"    }\n"
"\n"
"    reduct(acc, func) {\n"
"        for element in self {\n"
"            acc = func.call(acc, element);\n"
"        }\n"
"        return acc;\n"
"    }\n"
"\n"
"    reduce(func) {\n"
"        let iter = iterate(null);\n"
"        if !iter {\n"
"            Thread.abort(\"Can't reduce an empty sequnce.\");\n"
"        }\n"
"\n"
"        let res = iterator_value(iter);\n"
"        while iter = iterate(iter) {\n"
"            res = func.call(res, iterator_value(iter));\n"
"        }\n"
"\n"
"        return res;\n"
"    }\n"
"\n"
"    join(sep) {\n"
"        let first = true;\n"
"        let res = \"\";\n"
"        for element in self {\n"
"            if !first {\n"
"                res = res + sep;\n"
"            }\n"
"            first = false;\n"
"            res = res + element.to_string();\n"
"        }\n"
"        return res;\n"
"    }\n"
"\n"
"    join() {\n"
"        return join(\"\");\n"
"    }\n"
"\n"
"    to_list() {\n"
"        let result = List.new();\n"
"        for element in self {\n"
"            result.append(element);\n"
"        }\n"
"        return result;\n"
"    }\n"
"}\n"
"\n"
"class MapSequence < Sequence {\n"
"    let sequnce;\n"
"    let func;\n"
"\n"
"    new(seq, f) {\n"
"        sequnce = seq;\n"
"        func = f;\n"
"    }\n"
"\n"
"    iterate(iterator) {\n"
"        return sequnce.iterate(iterator);\n"
"    }\n"
"\n"
"    iterator_value(iterator) {\n"
"        return func.call(sequnce.iterator_value(iterator));\n"
"    }\n"
"}\n"
"\n"
"class WhereSequence < Sequence {\n"
"    let sequnce;\n"
"    let func;\n"
"\n"
"    new(seq, f) {\n"
"        sequnce = seq;\n"
"        func = f;\n"
"    }\n"
"\n"
"    iterate(iterator) {\n"
"        while iterator = sequnce.iterate(iterator) {\n"
"            if func.call(sequnce.iterator_value(iterator)) {\n"
"                break;\n"
"            }\n"
"        }\n"
"        return iterator;\n"
"    }\n"
"\n"
"    iterator_value(iterator) {\n"
"        return sequnce.iterator_value(iterator);\n"
"    }\n"
"}\n"
"\n"
"class String < Sequence {\n"
"    bytes {\n"
"        return StringByteSequence.new(self);\n"
"    }\n"
"\n"
"    code_points {\n"
"        return StringCodePointSequence.new(self);\n"
"    }\n"
"\n"
"    *(count) {\n"
"        if !(count is i32) || count < 0 {\n"
"            Thread.abort(\"Count must be a non-negative integer.\");\n"
"        }\n"
"        let result = \"\";\n"
"        for i in 0..(count - 1) {\n"
"            result = result + self;\n"
"        }\n"
"        return result;\n"
"    }\n"
"}\n"
"\n"
"class StringByteSequence < Sequence {\n"
"    let string;\n"
"\n"
"    new(str) {\n"
"        string = str;\n"
"    }\n"
"\n"
"    [index] {\n"
"        return string.byte_at(index);\n"
"    }\n"
"\n"
"    iterate(iterator) {\n"
"        return string.iterate_byte(iterator);\n"
"    }\n"
"\n"
"    iterator_value(iterator) {\n"
"        return string.byte_at(iterator);\n"
"    }\n"
"\n"
"    len {\n"
"        return string.byte_count;\n"
"    }\n"
"}\n"
"\n"
"class StringCodePointSequence < Sequence {\n"
"    let string;\n"
"    \n"
"    new(str) {\n"
"        string = str;\n"
"    }\n"
"\n"
"    [index] {\n"
"        return string.code_point_at(index);\n"
"    }\n"
"\n"
"    iterate(iterator) {\n"
"        return string.iterate(iterator);\n"
"    }\n"
"    \n"
"    iterator_value(iterator) {\n"
"        return string.code_point_at(iterator);\n"
"    }\n"
"}\n"
"\n"
"class List < Sequence {\n"
"    append_all(other) {\n"
"        for element in other {\n"
"            append(element);\n"
"        }\n"
"        return other;\n"
"    }\n"
"\n"
"    to_string() {\n"
"        let elements = join(\", \");\n"
"        return \"[%(elements)]\";\n"
"    }\n"
"\n"
"    +(other) {\n"
"        let res = self[0..-1];\n"
"        for element in other {\n"
"            res.append(element);\n"
"        }\n"
"        return result;\n"
"    }\n"
"\n"
"    *(count) {\n"
"        if !(count is i32) || count < 0 {\n"
"            Thread.abort(\"Count must be a non-negative integer.\");\n"
"        }\n"
"        let res = [];\n"
"        for i in 0..(count - 1) {\n"
"            res.append_all(self);\n"
"        }\n"
"        return res;\n"
"    }\n"
"}\n"
"\n"
"class Map {\n"
"    keys {\n"
"        return MapKeySequence.new(self);\n"
"    }\n"
"\n"
"    values {\n"
"        return MapValueSequence.new(self);\n"
"    }\n"
"\n"
"    to_string() {\n"
"        let first = true;\n"
"        let result = \"{\";\n"
"        for key in keys {\n"
"            if !first {\n"
"                result = result + \", \";\n"
"            }\n"
"\n"
"            first = false;\n"
"            result = result + \"%(key): %(self[key])\";\n"
"        }\n"
"        result = result + \"}\";\n"
"        return result;\n"
"    }\n"
"}\n"
"\n"
"class MapKeySequence < Sequence {\n"
"    let map;\n"
"\n"
"    new(m) {\n"
"        map = m;\n"
"    }\n"
"\n"
"    iterate(n) {\n"
"        return map.iterate(n);\n"
"    }\n"
"\n"
"    iterator_value(iterator) {\n"
"        return map.key_iterator_value(iterator);\n"
"    }\n"
"}\n"
"\n"
"class MapValueSequence < Sequence {\n"
"    let map;\n"
"\n"
"    new(m) {\n"
"        map = m;\n"
"    }\n"
"\n"
"    iterate(n) {\n"
"        return map.iterate(n);\n"
"    }\n"
"\n"
"    iterator_value(iterator) {\n"
"        return map.val_iterator_value(iterator);\n"
"    }\n"
"}\n"
"\n"
"class Range < Sequence {\n"
"    max {\n"
"        return Math.max(from, to);\n"
"    }\n"
"\n"
"    min {\n"
"        return Math.min(from, to);\n"
"    }\n"
"}\n"
"\n"
"class System {\n"
"    static print() {\n"
"        write_string(\"\n\");\n"
"    }\n"
"\n"
"    static print(obj) {\n"
"        write_object(obj);\n"
"        write_string(\"\n\");\n"
"        return obj;\n"
"    }\n"
"\n"
"    static print_all(sequnce, step) {\n"
"        for obj in sequnce {\n"
"            write_object(obj);\n"
"            write_string(step);\n"
"        }\n"
"        write_string(\"\n\");\n"
"    }\n"
"\n"
"    static print_all(sequnce) {\n"
"        print_all(sequnce, \", \");\n"
"    }\n"
"\n"
"    static write(obj) {\n"
"        write_object(obj);\n"
"        return obj;\n"
"    }\n"
"\n"
"    static write_all(sequnce, step) {\n"
"        for obj in sequnce {\n"
"            write_object(obj);\n"
"            write_string(step);\n"
"        }\n"
"    }\n"
"\n"
"    static write_all(sequnce) {\n"
"        write_all(sequnce, \", \");\n"
"    }\n"
"\n"
"    static write_object(obj) {\n"
"        let str = obj.to_string();\n"
"        write_string(str is String ? str : \"$<invalid to_string>$\");\n"
"    }\n"
"}\n"
"\n"
"class Math {\n"
"    static max(a: i32 | f64, b: i32 | f64) -> i32 | f64 {\n"
"        return a >= b ? a : b;\n"
"    }\n"
"\n"
"    static min(a: i32 | f64, b: i32 | f64) -> i32 | f64 {\n"
"        return a <= b ? a : b;\n"
"    }\n"
"}\n"
"\n"
"class VM {}\n"
"\n"
"class CFILE {}\n";
